<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java 内存泄露事故分析</title>
    <url>/2022/10/10/bugFix/</url>
    <content><![CDATA[<h3 id="问题描述">问题描述</h3>
<p><strong>电影票</strong>长期存在 <strong>ticket</strong> 模块堆栈内存溢出导致系统崩溃的问题，初期一直认为是订单量过大导致比价功能调用次数太多引起的内存溢出问题。经过排查 dump 日志未能定位到具体问题，最终特权选择多开 <strong>ticket</strong> 模块的方式来避免单机崩溃导致服务不可用的情况，但是此方法治标不治本，运维需要经常重启崩溃的 <strong>ticket</strong> 模块。</p>
<blockquote>
<p><em>电影票 ticket 模块在 h5 用户下单时，会调用异步比价功能，此功能使用 @Async 注解实现，意味着每有一笔订单都会启用一个比价线程</em></p>
</blockquote>
<p>本问题历时一年才得以解决，这其中经历了四个问题分析阶段</p>
<ol>
<li>
<p><strong>ticket</strong> 模块崩溃，根据 dump 日志发现内存中存在大量比价功能生成的对象，初步判断是短时订单量过大导致的，未有较好的解决办法，选择多开 <strong>ticket</strong> 模块顶住大量订单的压力。</p>
</li>
<li>
<p>运维侧报告 <strong>ticket</strong> 模块存在凌晨崩溃的情况，排查日志发现凌晨订单只有几笔，此时怀疑是比价功能存在一定问题，导致其产生的对象停留较久，但是依旧未排查到问题。</p>
<blockquote>
<p><em>因还是未定位到能导致内存溢出的问题，只能判断认为是虚拟机内存回收较慢导致的</em></p>
</blockquote>
</li>
<li>
<p>技术侧发现 <code>@Async</code> 注解支持选择线程池来将异步线程改为用线程池来执行，可以防止大量调用 <code>@Async</code> 导致生成了海量线程从而内存溢出。但是在本功能上线后，依然出现了 <strong>ticket</strong> 模块崩溃的问题。</p>
</li>
<li>
<p>经过以上三次排查，已基本确定本次问题是由代码问题引起的内存泄露，并不是因为电影票订单数据量过大导致的系统崩溃。随后重新开始排查问题，并最终定位到是因为 json 序列化引起的内存泄露。</p>
</li>
</ol>
<h3 id="定位思路">定位思路</h3>
<h4 id="步骤1">步骤 1</h4>
<p>首先使用 <strong>JProfiler</strong> 工具查看 <strong>dump</strong> 日志，按照保留大小倒序排序，可以发现最多的是 <code>String</code> 对象，这是因为 <code>YtbShowListResponse</code> 内存溢出对象中存储有请求接口返回的字符串内容，此内容包含一个影院下面的所有场次，所以内容较大。</p>
<p><img src="JProfiler1.png" alt="avatar"></p>
<center>
（JProfiler 工具查看 dump 日志）
</center>
<span id="more"></span>
<h4 id="步骤2">步骤 2</h4>
<p>查看对象的数据结构，发现本质是一个 <code>Map</code>，初步怀疑是不是 <strong>NutMap</strong> 第三方工具引起的</p>
<p><img src="YtbShowListResponse.png" alt="avatar"></p>
<center>
（YtbShowListResponse 数据结构）
</center>
<h4 id="步骤3">步骤 3</h4>
<p>使用 <strong>JProfiler</strong> 工具的图表功能，查看对象到 GC 根 (root) 的路径，可以发现最终是被 <strong>org.nutz.lang.Mirror</strong> 对象所持有，导致无法被回收</p>
<p><img src="JProfiler2.png" alt="avatar"></p>
<center>
（JProfiler 工具查看图标）
</center>
<h4 id="步骤4">步骤 4</h4>
<p>此时查看比价功能代码，可以发现 <code>YtbShowListResponse</code> 对象的使用都是正常的，并没有放置到 java 静态变量中等操作，但是根据 <strong>dump</strong> 日志分析其中的 <code>YtbShowListResponse</code> 对象，<code>YtbShowListResponse</code> 中 <code>content</code> 字段都是成功，即请求失败就不会出现内存泄露问题，问题代码范围进一步缩小。</p>
<p><img src="queryYtbOrderInfo.png" alt="avatar"></p>
<center>
（比价功能代码）
</center>
<h4 id="步骤5">步骤 5</h4>
<p>排查代码发现<em><strong> getResponse</strong></em> 方法有非常高的可疑性，使用了第三方序列化方式<em><strong> Json.fromJson</strong></em>，并且使用了 <strong>PType</strong> 第三方工具来标识序列化类型，更加可疑，此序列化方法和 <strong>org.nutz.lang.Mirror</strong> 同属于 <strong>nutz</strong> 第三方工具包，基本已锁定到问题代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;YtbShowBo&gt; <span class="title function_">getResponse</span><span class="params">()</span> {</span><br><span class="line">       <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="built_in">this</span>.getData();</span><br><span class="line">       <span class="keyword">if</span> (Strings.isBlank(data)) {</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YtbException</span>(<span class="string">"影托邦场次列表响应为空"</span>);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> Json.fromJson(<span class="keyword">new</span> <span class="title class_">PType</span>&lt;List&lt;YtbShowBo&gt;&gt;() {</span><br><span class="line">       }, data);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="步骤6">步骤 6</h4>
<p>为了验证是否是 json 序列化导致，在 <code>YtbShowListResponse</code> 上重写了<em><strong> finalize</strong></em> 方法，并在其中打印了日志，验证对象是否被回收了，采用对照法，使用 <strong>fastjson</strong> 包替换了序列化方法，执行相同比价功能，最终验证结果如下：</p>
<ol>
<li><em><strong>Json.fromJson</strong></em> 方法和 <strong>PType</strong> 共同使用情况下，会导致<em><strong> finalize</strong></em> 不被执行，也就意味着此对象不会被虚拟机回收</li>
<li><em><strong> JSON.parseObject</strong></em> 方法和 <strong>TypeReference</strong> 共同使用情况下，<em><strong>finalize</strong></em> 很快就执行了，意味着对象被回收了</li>
</ol>
<blockquote>
<p>java 的<em><strong> finalize</strong></em> 方法在生产环境是禁止使用的，<strong>对其的重写可能会造成虚拟机性能下降或者对象无法被回收的问题</strong>，最终导致系统崩溃（网上说的，未验证ㄟ (▔, ▔) ㄏ），本次只是在测试环境打印日志，方便检查对象是否被回收，<strong>切勿在生产环境使用本方法</strong>。</p>
</blockquote>
<blockquote>
<p><em>其实 java 虚拟机垃圾回收执行的很快</em></p>
</blockquote>
<h4 id="总结">总结</h4>
<p>到这里，其实问题已经得到了解决，但是为了提现我们热爱技术的一面，也为了彰显我们的钻研精神，那么还要提出疑问，为什么这会导致内存泄露？总结出以下几个问题：</p>
<ul>
<li>为什么 <strong>fastjson</strong> 不会出现内存泄露的问题？</li>
<li>明明序列化的对象是字符串 <strong>data</strong> 数据，生成后的对象也是 <code>List&lt;YtbShowBo&gt;</code>，怎么结果就成了 <code>YtbShowListResponse</code> 存到了虚拟机中无法被回收？</li>
<li>json 序列化的原理是什么？</li>
</ul>
<p>本着以上几个问题，我们进入了下一阶段，我们要找到问题本质～我们要搞清楚到底是什么东西，影响了虚拟机内存回收？</p>
<h3 id="追本溯源">追本溯源</h3>
<p>进入 <strong>nutz</strong> 的 jar 包源码，可以发现他使用了 <code>mirrorCache</code> 把所有使用到的序列化类型都缓存了起来，问题就出在了这里</p>
<p><img src="Mirror.png" alt="avatar"></p>
<center>
（json 序列化源码）
</center>
<p>这时就要开始使用我们的好帮手百度了，<strong>PType</strong> 实现了 <strong>ParameterizedType</strong> 接口，使用 <strong>ParameterizedType</strong> + 内存溢出为标题查到一篇文章<sup>①</sup>，说明 <strong>fastjson</strong> 也存在使用 <strong>ParameterizedType</strong> 不当导致的内存泄露问题，此问题已经被 <strong>fastjson</strong> 修复了。不过 <strong>nutz</strong> 包和 <strong>fastjson</strong> 包并不相同，但是这也印证了我们的观点，json 序列化如果使用不当确实会导致内存泄露的问题。</p>
<blockquote>
<p><strong>ParameterizedType</strong> 是 jdk 提供的用于处理带泛型类型的类的序列化方式<sup>②</sup></p>
</blockquote>
<p>比对了 <strong>nutz</strong> 包和 <strong>fastjson</strong> 的源码，发现了区别，<strong>fastjson</strong> 并没有直接使用序列化类型 <strong>Type</strong>，而是在其内部进行了重新实现，到这里，我们就能回答出前面三个问题中的两个了：</p>
<ul>
<li><strong>fastjson</strong> 采用了在 <strong>Type</strong> 中重新生成子序列化类型的方式，避免了内存泄露的问题</li>
<li> json 序列化的原理就是通过声明一个序列化类型，然后将字符串内容进行转换的过程</li>
</ul>
<p><img src="nuztAndFastjson.png" alt="avatar"></p>
<center>
（**nutz** 包和 **fastjson** 源码比较，左 **nutz**，右 **fastjson**）
</center>
<p>但是，第二个问题没有得到解答，为什么最终在内存中存储了大量的 <code>YtbShowListResponse</code> 而不是 <code>List&lt;YtbShowBo&gt;</code> 呢？</p>
<p>这个问题最终通过研究 <code>new TypeReference</code> 和 <code>new PType</code> 两者之间的区别得以解决</p>
<p>先看下声明序列化类型的写法，<code>new xxx(){}</code> 是 java 匿名内部类的写法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;YtbShowBo&gt; ytbShowBos = Json.fromJson(<span class="keyword">new</span> <span class="title class_">PType</span>&lt;List&lt;YtbShowBo&gt;&gt;() {</span><br><span class="line">}, data);</span><br></pre></td></tr></tbody></table></figure>
<p>此时，你只需要回想下学过的 java 基础，就能明白一点，java 的匿名内部类是依赖于其父类的，这就导致你在 dump 日志或者 debug 模式下查看匿名内部类对象时，都会惊奇的发现他的指针并不是指向他的内存地址，而是直接指向其父类</p>
<blockquote>
<p><em>匿名内部类其实极易导致内存泄露问题<sup>③</sup></em></p>
</blockquote>
<p><img src="debug.png" alt="avatar"></p>
<center>
（debug）
</center>
<p>到这里，你也就明白了为什么会出现内存泄露的问题，为什么内存中会有大量的 <code>YtbShowListResponse</code> 对象，因为每一个 <code>new PType</code> 都持有了其父类对象，当 <strong>PType</strong> 被放置到 <code>mirrorCache</code> 中缓存起来时，也就导致他持有的父对象再也无法被回收了，我们也就解答了前面第二个问题，也就明白了这次内存泄露的本质</p>
<h5 id="这就结束了吗？">这就结束了吗？</h5>
<p>问题找到了，但是我们还没有去解决问题，前面好像已经找到了解决办法，就是替换第三方序列化工具，使用 <strong>fastjson</strong> 替代 <strong>nutz</strong>，但是这样好像我们学到的知识没用上，如何使用 java 基础解决这个问题？让我们倒回前文有关匿名内部类的部分，解决办法就藏在这里面 ↑</p>
<h5 id="终极解决方案：">终极解决方案：</h5>
<p>将在方法内部创建的 <strong>Type</strong> 改为静态变量</p>
<p><code>private static final PType&lt;List&lt;YtbShowBo&gt;&gt; YTB_SHOW_BO_TYPE = new PType&lt;List&lt;YtbShowBo&gt;&gt;() {};</code></p>
<p>本问题随即解决</p>
<blockquote>
<p>当匿名内部类成为静态变量时，根据我们学过的 java 基础知识，java 类下的静态变量属于类，被所有类实例对象所共享，当且仅当在类初次加载时会被初始化</p>
</blockquote>
<h5 id="到此为止了，但是没有完全为止">到此为止了，但是没有完全为止</h5>
<p>本次内存泄露问题已经圆满解决，大家也跟着本文档学习了解了如何排查问题，如何分析问题，如何解决问题。但是本文档只是个引子，希望在以后的工作中大家都能保持钻研精神，不怕问题，解决问题。</p>
<h3 id="附录">附录</h3>
<p>收录相关在排查问题时查询到的有参考意义的博客内容</p>
<p>附录① <a href="https://blog.csdn.net/weixin_33358099/article/details/114828657">Java 反序列化 json 内存溢出_fastjson 反序列化使用不当导致内存泄露</a></p>
<p>附录② <a href="https://blog.csdn.net/JustBeauty/article/details/81116144">ParameterizedType 详解</a></p>
<p>附录③ <a href="https://blog.csdn.net/feiying0canglang/article/details/124946774">JVM–Java 内存泄露–匿名内部类–原因 / 解决方案</a></p>
]]></content>
      <categories>
        <category>开发日常</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome 浏览器内置谷歌翻译无法使用解决方案</title>
    <url>/2022/10/10/chromeTranslate/</url>
    <content><![CDATA[<p>google 近期关闭了国内谷歌翻译网站，但是 chrome 浏览器内置的翻译功能用起来比较顺手，可以通过修改 host 的方式临时解决下</p>
<h3 id="修改host教程">修改 host 教程</h3>
<h4 id="进入etc文件夹">进入 etc 文件夹</h4>
<ul>
<li>mac: 右键访达 - 前往文件夹 - 输入 “etc/hosts”</li>
<li>windows: C:\Windows\System32\drivers\etc</li>
</ul>
<p>修改文件，添加以下内容：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">203.208.40.66 translate.google.com</span><br><span class="line">142.250.4.90 translate.googleapis.com</span><br></pre></td></tr></tbody></table></figure>
<p>保存修改后，chrome 即可正常使用</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用指北</title>
    <url>/2022/10/16/UseHexoOne/</url>
    <content><![CDATA[<p>第一次使用 Hexo 还是在 2017 年，那时候到处了解学习新兴技术，go 也是在那段时间听说并进行了简单学习；当时应该是在搜如何建一个个人博客，然后就搜到了 Hexo 的相关文章，因为其借用 GitPage 相关特性无需自建服务器，直接依托 github 就能建立个人博客，并且也能支持搜索引擎收录，这些亮点在当时的我看来还是很酷的（现在依然觉得很酷～），但是当时在研究完如何安装并成功放到 GitPage 之后，因为没有良好的书写文档的习惯，个人博客也就搁置了，不过当时还是很惊叹于 Hexo 运行后的博客页面，风格很吸引人。</p>
<p>最近使用 github 时，看了看自己的仓库发现了这个被遗弃的博客仓库，正好最近意识到了文档的重要性，并且也在尝试书写一些，而且用的也是 markdown 格式，能够无缝衔接到 Hexo 上，就准备把这个仓库重新用起来，希望不算太晚吧。</p>
<div class="note info"><p>说起来，markdown 也是 2017 那年学习使用的，因为当时正值毕业季，需要写个人简历，可能大部分人都是用的智联吧，后来我同学推荐我用乔布简历，写完效果拔群～比智联不知道高到哪里去了，后来同学又推荐我使用 markdown，简单的编写规则加上自由的样式控制可以写出非常好看的简历，并且也足够小众足够酷（但是现在基本程序员已经都会用这个工具了），这才是程序员写个人简历的工具～从此之后我写文档基本都是用 markdown 来写</p>
</div>
<span id="more"></span>
<h2 id="Hexo">Hexo</h2>
<h3 id="Hexo安装方式">Hexo 安装方式</h3>
<p>鉴于国情，很多人学习技术更多的是在 csdn 或者其他个人博客，通过别人学习后总结的文章来学习，确实这样学起来更快，并且很多官方网站都是英文的，而 csdn 或者个人博客相当于一个汉化的过程，但是 csdn 会存在一个问题就是文章中的内容会出现过时的情况，所以还是建议直接前往官网学习，并且 <a href="https://hexo.io/zh-cn/docs/" title="Hexo官网">Hexo 官网</a>是有简体中文的。</p>
<h4 id="安装git">安装 git</h4>
<p>直接去 git 官网下载 64 位的 exe 安装文件即可</p>
<h4 id="安装node">安装 node</h4>
<p>node 版本是个坑，很多 npm 包是对 node 版本有要求的，并且有的时候过新的 node 版本也会导致 npm 包失败，我尝试 Hexo 安装成功的 node 环境版本是 <em>14.16.1</em></p>
<h4 id="安装Hexo">安装 Hexo</h4>
<p>npm 全局安装 Hexo</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g hexo-cli</span></span><br></pre></td></tr></tbody></table></figure>
<p>Hexo 初始化</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install</span></span><br></pre></td></tr></tbody></table></figure>
<p>配置文件</p>
<p>_config.yml 是 Hexo 的配置文件，可以在其中设置一些基本参数，例如博客名称、作者名称及一些插件的配置信息</p>
<h4 id="安装主题NEXT">安装主题 NEXT</h4>
<p>Hexo 默认主题外观还是比较一般的，Hexo 支持很多扩展主题，我使用的是 NexT 主题，国内大部分网站也是推荐使用这个</p>
<p>但是这就引出了一个坑，因国内大部分介绍 Hexo 的博客文章都停留在 2020 年或 2020 年以前了，假如没有去 Hexo 官方学习安装方式，而是直接按照国内博客来，那么你安装主题的命令一定是</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></tbody></table></figure>
<p>在安装完这个主题后，你会发现使用起来都很正常，但是几个第三方插件却会出现不好使的情况，并且也没有任何参考解决方案，例如当你要用 leancloud 来当浏览量插件时，页面会出现报错的情况。这实际上是因为 NexT 原作者出现了长期不在线的情况，导致其他成员无法管理已有仓库，所以重新创建了新的分支<a href="https://github.com/next-theme/hexo-theme-next/issues/4" title="解释博客">解释博客</a></p>
<p>正确的安装主题命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/next-theme/hexo-theme-next themes/next</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>命令后缀的 themes/next 不必须按照示例来，next 是指 clone 后的所在文件夹名，这个可以任意命名，只需要 clone 后，将根目录下的_config.yml 中 theme 参数配置为对应的文件夹名就可以了</p>
</blockquote>
<p>Hexo 新版本下，修改主题的配置文件有了新的方式，只需要在根目录下建立_config.xxx.yml，xxx 对应的是 themes 下使用主题所在的文件夹名</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java 面试题汇总</title>
    <url>/2022/11/02/javaAudition/</url>
    <content><![CDATA[<p>本文记录一些比较贴合实际开发的常遇到的 java 面试题，方便后续面试</p>
<h3 id="【易】StringBuilder和StringBuffer区别是什么？">【易】StringBuilder 和 StringBuffer 区别是什么？</h3>
<p>StringBuffer 是线程安全的，StringBuilder 是非线程安全的，但是 StringBuilder 性能高于 StringBuffer，单线程下推荐使用 StringBuilder，<strong>StringBuffer 内部采用 synchronized 来实现并发下的线程安全，也导致性能较于 StringBuilder 更低</strong> <em>【加分项】</em></p>
<h3 id="【中】在-Java-程序中怎么保证多线程的运行安全？">【中】在 Java 程序中怎么保证多线程的运行安全？</h3>
<ul>
<li>使用安全类，比如 Java. util. concurrent 下的类</li>
<li>使用自动锁 synchronized</li>
<li> 使用手动锁 Lock</li>
</ul>
<h3 id="【难】synchronized的底层实现原理是什么？锁升级原理是什么？">【难】synchronized 的底层实现原理是什么？锁升级原理是什么？</h3>
<span id="more"></span>
<h3 id="【易】遍历List操作的几种方式？">【易】遍历 List 操作的几种方式？</h3>
<ul>
<li>for 循环遍历</li>
<li>增强 for 循环</li>
<li>迭代器循环</li>
<li> jdk8 后的 lambda 表达式，foreach 方法 <em>【加分项】</em></li>
</ul>
<h3 id="【中】遍历循环删除元素的话你会用那种方法来操作？">【中】遍历循环删除元素的话你会用那种方法来操作？</h3>
<p>使用迭代器循环删除</p>
<h3 id="【中】说一下-session-的工作原理？">【中】说一下 session 的工作原理？</h3>
<p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了</p>
<h3 id="【中】try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？">【中】try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3>
<p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行</p>
<h3 id="【低】spring-事务实现方式有哪些？">【低】spring 事务实现方式有哪些？</h3>
<p><strong>声明式事务</strong>：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）</p>
<p><strong>编码方式</strong>：提供编码的形式管理和维护事务</p>
<h3 id="【低】MySQL-的内连接、左连接、右连接有什么区别？">【低】MySQL 的内连接、左连接、右连接有什么区别？</h3>
<p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>
<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h3 id="【低】mysql默认事务隔离级别？">【低】mysql 默认事务隔离级别？</h3>
<p>REPEATABLE-READ 可重复读</p>
<h3 id="【中】乐观锁和悲观锁的区别？">【中】乐观锁和悲观锁的区别？</h3>
<p><strong>乐观锁</strong>：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据</p>
<p><strong>悲观锁</strong>：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放</p>
<h3 id="【难】如何保证接口幂等性？">【难】如何保证接口幂等性？</h3>
<div class="note info"><p>没有唯一正确的答案，更多地考察面试者的实际经验和总结能力</p>
</div>
<ol>
<li>定义唯一 msgId，根据 msgId 判断是否重复</li>
<li>结合业务逻辑使用乐观锁来限制，例如订单回调的业务逻辑，可以根据回调时订单的当前状态来判断本次回调内容是否要消费，并且在消费时借助乐观锁来进行限制，添加前置状态校验，类似<br>
<em>【加分项】</em></li>
</ol>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> `<span class="keyword">order</span>` <span class="keyword">set</span> `status` <span class="operator">=</span> <span class="string">'status'</span> <span class="keyword">where</span> `status` <span class="operator">=</span> <span class="string">'beforeStatus'</span>;</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>每个请求操作必须有唯一的 ID，而这个 ID 就是用来表示此业务是否被执行过的关键凭证，例如，订单支付业务的请求，就要使用订单的 ID 作为幂等性验证的 Key；每次执行业务之前必须要先判断此业务是否已经被处理过；第一次业务处理完成之后，要把此业务处理的状态进行保存，比如存储到 Redis 中或者是数据库中，这样才能防止业务被重复处理</li>
</ol>
<h3 id="【难】JVM中有哪些垃圾回收算法？">【难】JVM 中有哪些垃圾回收算法？</h3>
<h3 id="【中】什么是Redis缓存穿透、击穿、雪崩？">【中】什么是 Redis 缓存穿透、击穿、雪崩？</h3>
<p><strong>缓存穿透</strong>：指访问一个缓存和数据库中都不存在的 key，由于这个 key 在缓存中不存在，则会到数据库中查询，数据库中也不存在该 key，无法将数据添加到缓存中，所以每次都会访问数据库导致数据库压力增大</p>
<blockquote>
<ol>
<li>将空 key 添加到缓存中</li>
<li>使用布隆过滤器过滤空 key</li>
</ol>
</blockquote>
<p><strong>缓存击穿</strong>：指大量请求访问缓存中的一个 key 时，该 key 过期了，导致这些请求都去直接访问数据库，短时间大量的请求可能会将数据库击垮</p>
<blockquote>
<ol>
<li>添加互斥锁或分布式锁，让一个线程去访问数据库，将数据添加到缓存中后，其他线程直接从缓存中获取</li>
<li>热点数据 key 不过期，定时更新缓存</li>
</ol>
</blockquote>
<p><strong>缓存雪崩</strong>：指在系统运行过程中，缓存服务宕机或大量的 key 值同时过期，导致所有请求都直接访问数据库导致数据库压力增大</p>
<blockquote>
<ol>
<li>将 key 的过期时间打散，避免大量 key 同时过期</li>
<li>使用互斥锁重建缓存</li>
</ol>
</blockquote>
<h3 id="【中】Redis怎么实现分布式锁？">【中】Redis 怎么实现分布式锁？</h3>
<p>使用命令 setnx 来实现，假如当前 key 有值则说明锁已经被占有，程序在使用完锁后需要调用 del 释放锁；</p>
<blockquote>
<p>redis 的分布式锁会存在锁超时的情况，如果程序执行时间过长会导致锁自动解开，从而分布式锁就失效了，可以借助 Redission 的 watchdog 机制来解决；因为设置锁和设置过期时间是分开操作的，可能存在设置完锁服务宕机的情况，导致锁没有正确释放，这些可以通过 lua 脚本来实现，合并到一条命令中，也可以通过 Redission 来实现。<em>【加分项】</em></p>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>helloworld</category>
      </categories>
      <tags>
        <tag>helloworld</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 中多表 LEFT JOIN 的误区</title>
    <url>/2022/11/12/mysqlLeftJoin/</url>
    <content><![CDATA[<p>最近在日常看项目慢 SQL 日志的时候，发现项目里的用户管理查询 SQL 略慢，基本要在一秒以上，决定优化一下，结果优化了半天还优化出来个问题，研究了好久才发现原因，其实是我的使用姿势不对</p>
<h4 id="背景介绍">背景介绍</h4>
<p>用户列表查询使用了多表关联，其中使用了 7 张表做 LEFT JOIN 关联查询，拼接了很多查询条件，并且还穿插了几个子查询。所以做了一下优化，重新梳理了表逻辑</p>
<p>其中有三张表分别是 <code>user</code> 用户表，<code>user_brand</code> 用户品牌表，<code>user_add_account</code> 用户加款账户表，查询逻辑是</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.name, group_concat(ub.name) brandName, group_concat(uac.account) account</span><br><span class="line"><span class="keyword">FROM</span> `<span class="keyword">user</span>` u </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `user_brand` ub <span class="keyword">ON</span> u.id <span class="operator">=</span> ub.user_id </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `user_add_account` uac <span class="keyword">ON</span> u.id <span class="operator">=</span> uac.user_id</span><br></pre></td></tr></tbody></table></figure>
<p>结果出现了 brandName 和 account 相同内容重复的问题，之前 brandName 是通过子查询得出的，所以没有存在重复的情况，结果改成 LEFT JOIN 出现了重复问题，这个问题也是研究了好久才发现，其实是因为对 SQL 查询原理掌握不牢导致的</p>
<span id="more"></span>
<h4 id="原因">原因</h4>
<p>三表的关系是，<code>user</code> 和 <code>user_brand</code> 是一对多的关系，<code>user</code> 和 <code>user_add_account</code> 也是一对多的关系，在 mysql 中，如果多表使用 LEFT JOIN 来进行关联查询，并且存在多个左表和右表的一对多关系，mysql 会将多个右表的条数进行笛卡尔积对应到左表上，就导致了 <code>user_brand</code> 和 <code>user_add_account</code> 都存在重复出现的情况</p>
<h5 id="问题SQL">问题 SQL</h5>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.id, ub.brand_id, uaa.account </span><br><span class="line"><span class="keyword">FROM</span> `<span class="keyword">user</span>` u </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `user_brand` ub <span class="keyword">ON</span> u.id <span class="operator">=</span> ub.user_id </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `user_add_account` uaa <span class="keyword">ON</span> uaa.user_id <span class="operator">=</span> u.id </span><br></pre></td></tr></tbody></table></figure>
<h5 id="查询结果">查询结果</h5>
<table>
<thead>
<tr>
<th>id</th>
<th>brand_id</th>
<th>account</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>1</td>
<td>5719xxxxxxxx901</td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>5719xxxxxxxx555</td>
</tr>
<tr>
<td>11</td>
<td>1</td>
<td>1209xxxxxxxx902</td>
</tr>
<tr>
<td>11</td>
<td>2</td>
<td>1209xxxxxxxx902</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
<td>1209xxxxxxxx902</td>
</tr>
</tbody>
</table>
<p>很明显可以看出，id 为 8 的数据因为 <code>user_add_account</code> 存在两条数据，导致会查出来两条数据，id 为 11 的数据因为 <code>user_brand</code> 存在三条数据，导致会查出来三条数据，假如有一个 id 为 20 的数据，关联到 <code>user_brand</code>2 条，关联到 <code>user_add_account</code> 三条，那最终会查出 6 条数据</p>
<h4 id="怎么解决？">怎么解决？</h4>
<p>两种方案，第一种可以在 group_concat 中加 DISTINCT 关键词去重，因为实际业务查询只是为了看关联到 user_brand 的数据，去重并不会影响业务的展示</p>
<p>第二种可以去除 LEFT JOIN 关联的表，采用单独查询后拼接的方式，也能避免本情况，顺便还能减少表关联，减轻数据库查询压力</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>记管理人员拓展活动思考</title>
    <url>/2022/10/27/manage/</url>
    <content><![CDATA[<p>2022 年 10 月 15 日参加了管理人员拓展活动，也是第一次参加拓展活动，认识了很多人，也同时有了一些感悟，本文仅做自身感悟记录。</p>
<p>当日活动有一个七巧板比赛，是个多人分组协同合作的项目，赛后教练也是组织大家做了复盘，本次的笔记也主要是来源于此次复盘的一些发言和自身感悟。</p>
<h3 id="一致性">一致性</h3>
<p>如何理解这个标题？一致性指的就是身为管理高层，要有统一的思想，要有一致认可的行动方案。不能小明有小明的方案，小强有小强的方案，并且这两个方案还在同时执行，这只会导致下属行动混乱，没有固定的目标。</p>
<span id="more"></span>
<h3 id="项目实施前规划方案的重要性">项目实施前规划方案的重要性</h3>
<p>每次做什么事前，你是会准备一个计划方案来执行，还是先执行起来，再慢慢修正呢？</p>
<p>这次七巧板就遇到了这个问题，当教练公布完游戏规则后，游戏就已经开始了，每个组手上都有了一份属于他们自己的任务，游戏时间只有 30 分钟，这时你是选择暂停所有人的行动，花 3-5 分钟甚至更多的时间来收集任务并归纳输出一套解决方案，还是先让整个游戏运转起来，然后等遇到问题再解决问题呢？</p>
<p>当时我们选择了先行动，在思考，最终在游戏进行了约 20 分钟后，才逐渐摸清了套路，并进行了调整，不过为时已晚，没能拿到游戏的满分。但是假如我们先花些时间，查看每个小组的任务，总结其中的共同点，那么可能 20 分钟就能完成这场游戏。</p>
<p>由此可见，实际行动前的准备何其重要，提前了解任务目标、游戏规则并制定方案，不正如我们实际工作中的了解客户需求，按照客户的规定提供项目实施计划吗？但是当我们跳过这些准备，直接开始实施，想必项目实施的结果如同游戏结果一般，杂乱无章，一团糟糕，最终引起客户的投诉。</p>
<p>当然在我们的日常工作中，很少会出现这么紧迫的情况，更多的是先得到需求并与客户研讨，然后逐步执行最终落地。这就更需要我们眼光放长远，不要专注于眼前利益、急干蛮干；提前统筹规划，制定出详细的计划方案，让项目的运行始终符合我们的预期，最终完美落地。</p>
<h3 id="动态修正">动态修正</h3>
<p>什么是动态修正？没有什么计划一开始就是完美无缺的，做到万无一失。但是我们可以在计划进行中穿插早会、周会等多种形式，及时对当前进度进行总结复盘，发现其中的问题并进行修正，形成闭环。最不应该的是项目已出现许多问题，却依然视而不见，坚持既定计划，最终导致计划失败或者计划完成但是效果很差。不惧怕问题，视项目中出现的问题为自己改正的契机，正是暴露出的这些问题，才能逐步让自己的计划变得完善，也让自己有了应对经验。</p>
]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>spotbugs 使用指南</title>
    <url>/2022/10/10/spotbugs/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>代码质量主要依靠代码检查来进行，但当前代码检查占用较多工时。现推荐一个比较成熟的代码检查插件，要求 JAVA 开发每次提交代码前都应使用插件自检，可以一定程度上减少代码检查所用的时间，帮助开发人员规范编码习惯，提高编码水平，本插件不能替代阿里巴巴开发规范插件，只是对其的补充。</p>
<h2 id="SpotBugs使用说明">SpotBugs 使用说明</h2>
<h3 id="安装方法">安装方法</h3>
<p>在 IDEA 中，点击工具类 <strong>File-&gt;Settings-&gt;Plugins</strong> 后，切换到 <strong>Marketplace</strong> 标签，在输入框中输入 spotbugs，查询到 <strong>SpotBugs</strong> 插件，点击 <strong>install</strong> 按钮安装插件，如图所示：</p>
<p><img src="SpotBugsInstall.png" alt="avatar"></p>
<center>
SpotBugs 安装
</center>
<span id="more"></span>
<h3 id="使用手册">使用手册</h3>
<h4 id="使用步骤">使用步骤</h4>
<p>SpotBugs 的使用方式是通过插件扫描代码的方式来检查出代码中隐含的 bug，首先切换 idea 任务栏到 SpotBugs 下（截图红字 3）。SpotBugs 主要有两种扫描方式，可全项目扫描或单模块扫描：</p>
<ul>
<li>全项目扫描使用截图红字 2 中第三个按钮</li>
<li>单模块扫描首先选择需要扫描的模块（截图红字 1），然后点击截图红字 2 中第一个按钮</li>
</ul>
<blockquote>
<p>说明：截图红字 3 中三个按钮依次为：扫描选中模块不包含 TEST 类；扫描选中模块包含 TEST 类；扫描全项目</p>
</blockquote>
<p><img src="SpotBugsUseStepOne.png" alt="avatar"></p>
<center>
SpotBugs 使用步骤
</center>
<h4 id="BUG说明">BUG 说明</h4>
<p>SpotBugs 扫描出的问题主要分为几个大类，每个大类中包含多个具体问题，具体问题有自己对应的处理优先级，分为高中低三级。现针对具体问题做解释说明，方便修改错误代码。本文档并未描述 SpotBugs 支持的全部问题，只针对每个大类列举有特点且较难理解的问题，未在本文档中出现但是被 SpotBugs 扫描出的问题，开发者也应自行查找处理，附 <a href="https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html" title="SpotBugs官方校验规则文档">SpotBugs 官方校验规则文档</a></p>
<h5 id="高危（强制修改）">高危（强制修改）</h5>
<h6 id="1-1-No-relationship-between-generic-parameter-and-method-argument">1.1 No relationship between generic parameter and method argument</h6>
<p>方法参数和传入参数存在泛型不一致的情况<br>
<br><br>
<font color="#FF0000">反例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">strList.add(<span class="string">"1"</span>);</span><br><span class="line">List&lt;Long&gt; idList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">idList.add(<span class="number">1L</span>);</span><br><span class="line">idList.add(<span class="number">2L</span>);</span><br><span class="line">idList.add(<span class="number">3L</span>);</span><br><span class="line">idList.removeAll(strList);</span><br></pre></td></tr></tbody></table></figure>
<h6 id="1-2-Call-to-equals-comparing-different-types">1.2 Call to equals() comparing different types</h6>
<p>equals 方法比较的双方不是相同类型<br>
<br><br>
<font color="#FF0000">反例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">cn.common.enums.OrderStatusEnum.REFUNDED.equals(cn.common.kentucky.enums.OrderStatusEnum.REFUNDED)</span><br></pre></td></tr></tbody></table></figure>
<h6 id="1-3-Nullcheck-of-value-previously-dereferenced">1.3 Nullcheck of value previously dereferenced</h6>
<p>空值检查顺序错误<br>
<br><br>
<font color="#FF0000">反例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> OrderDao.getOrder(dto.getId());</span><br><span class="line"><span class="keyword">if</span> (BreakUpType.CHILD.equals(order.getBreakUpType())) {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (order == <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleMessage</span>(ErrorCodeEnum.NO, <span class="string">"订单不存在"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="1-4-A-parameter-is-dead-upon-entry-to-a-method-but-overwritten">1.4 A parameter is dead upon entry to a method but overwritten</h6>
<p>错误的认为对参数的覆盖会回传给调用者<br>
<br><br>
<font color="#FF0000">反例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">partialH5Refund</span><span class="params">(Long id, String refundNo, String content, OrderRefund orderRefund)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">	<span class="comment">// String类型采用值传递，在方法中修改参数并不会影响原参数</span></span><br><span class="line">    content = String.format(<span class="string">"系统同步部分退款, 退款交易流水号[%s]"</span>, refundNo);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><span><font color="#D2B48C">说明：</font>JAVA 中当传入参数是对象时，修改对象属性是可以生效的，但是直接赋值覆盖对象的操作，是不会影响原参数的；String 类在 JAVA 中是值传递，对其的修改不会影响原参数。具体有关 JAVA 值传递和引用传递的相关介绍可参考文章 <a href="https://zhuanlan.zhihu.com/p/388486387" title="JAVA值传递和引用传递">JAVA 值传递和引用传递</a></span></p>
<h6 id="1-5-Self-assignment-of-clearInterval-rather-than-assigned-to-field">1.5 Self assignment of clearInterval rather than assigned to field</h6>
<p>在 setValue 中错误的将传参的值赋值给传参<br>
<br><br>
<font color="#FF0000">反例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClearInterval</span><span class="params">(Long clearInterval)</span> {</span><br><span class="line">	<span class="comment">// 应该使用this引用</span></span><br><span class="line">    clearInterval = clearInterval;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="1-6-Class-names-shouldn’t-shadow-simple-name-of-superclass">1.6 Class names shouldn’t shadow simple name of superclass</h6>
<p>子类名称不应和父类相同<br>
<br><br>
<font color="#FF0000">反例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConfig</span> <span class="keyword">extends</span> <span class="title class_">cn</span>.kentucky.order.config.OrderConfig</span><br></pre></td></tr></tbody></table></figure>
<h6 id="1-7-Random-object-created-and-used-only-once">1.7 Random object created and used only once</h6>
<p>推荐使用 java.security.SecureRandom 代替 Random</p>
<h6 id="1-8-Boxing-unboxing-to-parse-a-primitive">1.8 Boxing/unboxing to parse a primitive</h6>
<p>使用 Integer.parse 代替 Integer.valueOf；Integer.valueOf 会涉及多次拆箱装箱操作，经历了 String - int - Integer - int 的过程</p>
<h6 id="1-9-Reliance-on-default-encoding">1.9 Reliance on default encoding</h6>
<p>使用 new String、 getBytes 等方法需要指定编码格式，默认编码格式会因服务所在平台发生改变，这会产生意想不到的问题<br>
<br><br>
<font color="#006666">正例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = plainText.getBytes(StandardCharsets.UTF_8);</span><br></pre></td></tr></tbody></table></figure>
<h6 id="1-10-HTTP-Response-splitting-vulnerability">1.10 HTTP Response splitting vulnerability</h6>
<p>禁止将用户提交的参数直接放置到 response header 上或作为重定向参数，这可能会出现安全漏洞，具体描述参考 <a href="https://blog.csdn.net/qq_35976271/article/details/103276682" title="HTTP Response Splitting">HTTP Response Splitting</a><br>
<br><br>
<font color="#FF0000">反例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">referer</span> <span class="operator">=</span> request.getHeader(<span class="string">"REFERER"</span>);</span><br><span class="line">response.sendRedirect(referer);</span><br></pre></td></tr></tbody></table></figure>
<h5 id="中等（强制修改）">中等（强制修改）</h5>
<h6 id="2-1-equals-method-overrides-equals-in-superclass-and-may-not-be-symmetric">2.1 equals method overrides equals in superclass and may not be symmetric</h6>
<p>JAVA 中当子类使用 lombok 插件的 @Data 注解时，必须配上 @EqualsAndHashCode (callSuper = true)<br>
<br><br>
<font color="#D2B48C">说明：</font>@Data 默认使用 @EqualsAndHashCode (callSuper = false)，当在子类中使用此属性时，调用 equals 方法只会比较子类的属性，不会比较继承自父类的属性，极易产生不符合预期的结果（网上提示，此注解同时会产生父子类互相调用 equals 方法结果不相同的问题，即（a.equals (b) == b.equals (a)），但是实测不会产生本问题，因 lombok 同时生成了 canEqual 方法）</p>
<p><font color="#006666">正例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">McOrderVO</span> <span class="keyword">extends</span> <span class="title class_">McOrder</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br></pre></td></tr></tbody></table></figure>
<h6 id="2-2-Possible-null-pointer-dereference-in-method-on-exception-path">2.2 Possible null pointer dereference in method on exception path</h6>
<p>当代码经过 exception 异常处理时，存在可能的空值引用<br>
<br><br>
<font color="#FF0000">反例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; paramMap = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    paramMap = commonDingTalkPayService.payForApplet(aliConfig.getAppId());</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">}</span><br><span class="line"><span class="type">MessageBean</span> <span class="variable">payInfoData</span> <span class="operator">=</span> wechatPayService.getPayInfo(orderNo, order.getUserId());</span><br><span class="line"><span class="type">PayInfoVo</span> <span class="variable">data</span> <span class="operator">=</span> (PayInfoVo)payInfoData.getData();</span><br><span class="line"><span class="comment">// paramMap 默认声明是null值，当在try中抛出错误时，会经过异常处理但是paramMap依然保持null值，会在后续put时引发空指针问题</span></span><br><span class="line">paramMap.put(<span class="string">"payInfo"</span>, data);</span><br></pre></td></tr></tbody></table></figure>
<h6 id="2-3【推荐】May-expose-internal-representation-by-incorporating-reference-to-mutable-object">2.3【推荐】May expose internal representation by incorporating reference to mutable object</h6>
<p>不建议当对象中的属性也是对象时，其 get 和 set 方法直接进行赋值操作或返回操作，而是 set 时将传入参数进行拷贝并返回，get 时将属性拷贝并返回；如果直接使用传参赋值，会造成修改传参的效果被同步，引起与开发预期不符的问题。具体问题案例可参考<a href="https://www.cnblogs.com/hyddd/articles/1391098.html" title="属性拷贝">属性拷贝</a><br>
<br><br>
<font color="#006666">正例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date regDate ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRegDate</span><span class="params">(Date regDate)</span> {</span><br><span class="line">		<span class="comment">// 将传参的拷贝赋值给当前属性</span></span><br><span class="line">        <span class="built_in">this</span>.regDate = (Date) regDate.clone();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getRegDate</span><span class="params">()</span> {</span><br><span class="line">		<span class="comment">// 将当前属性拷贝返回出去</span></span><br><span class="line">        <span class="keyword">return</span> (Date) regDate.clone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="2-4【推荐】May-expose-internal-representation-by-returning-reference-to-mutable-object">2.4【推荐】May expose internal representation by returning reference to mutable object</h6>
<p>问题同 2.3，本问题是不建议直接返回原属性，而是返回属性的拷贝值</p>
<h6 id="2-5-May-expose-internal-representation-by-returning-reference-to-mutable-object">2.5 May expose internal representation by returning reference to mutable object</h6>
<p>静态集合常量应该是 final 型的，不允许修改</p>
<h6 id="2-6-Field-isn’t-final-and-can’t-be-protected-from-malicious-code">2.6 Field isn’t final and can’t be protected from malicious code</h6>
<p>字段未被 final 修饰，存在被修改的风险</p>
<h6 id="2-7-Field-should-be-package-protected">2.7 Field should be package protected</h6>
<p>属性应该用 protected 保护</p>
<h6 id="2-8-Field-is-a-mutable-collection-which-should-be-package-protected">2.8 Field is a mutable collection which should be package protected</h6>
<p>集合属性应该使用 protected 保护</p>
<h6 id="2-9-Field-isn’t-final-but-should-be">2.9 Field isn’t final but should be</h6>
<p>属性应该被设置为 final</p>
<h6 id="2-10-Field-is-a-mutable-array">2.10 Field is a mutable array</h6>
<p>集合属性存在被修改的风险<br>
<br><br>
<span><font color="#006666">正例：</font>涉及 2.3-2.8</span></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMap</span> {</span><br><span class="line">  <span class="comment">// list也应设置为不可修改的类型，并且建议使用list替换array格式，array只能通过protected修改来防止修改。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; UPLOAD_IMAGE_TYPES = ImmutableList.of(<span class="string">"image/jpeg"</span>, <span class="string">"image/png"</span>, <span class="string">"image/bmp"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CANCEL</span> <span class="operator">=</span> <span class="string">"CANCEL"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer,String&gt; map ;</span><br><span class="line">  <span class="keyword">static</span> {</span><br><span class="line">    Map&lt;Integer,String&gt; tempMap  = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    tempMap.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">    tempMap.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">	<span class="comment">// 禁止修改集合</span></span><br><span class="line">    map = Collections.unmodifiableMap(tempMap);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="2-11-Non-transient-non-serializable-instance-field-in-serializable-class">2.11 Non-transient non-serializable instance field in serializable class</h6>
<p>实现序列化的类中存在未实现序列化的属性，推荐类中添加系列化标识</p>
<h6 id="2-12-Serializable-inner-class">2.12 Serializable inner class</h6>
<p>实现了序列化标识的内部类建议都为静态内部类，可以减少序列化时必须要关联外部类的问题</p>
<h6 id="2-13-Method-may-fail-to-close-stream">2.13 Method may fail to close stream</h6>
<p>使用 JAVA 的 IO 流时，必须在 finally 块中对流进行关闭</p>
<h6 id="2-14-Format-string-should-use-n-rather-than-n">2.14 Format string should use %n rather than \n</h6>
<p>String 的 format 方法应该使用 % n 来进行换行</p>
<h6 id="2-15-Useless-object-created">2.15 Useless object created</h6>
<p>问题同 3.2</p>
<h6 id="2-16-Method-may-fail-to-clean-up-stream-or-resource-on-checked-exception">2.16 Method may fail to clean up stream or resource on checked exception</h6>
<p>JAVA 的 IO 流使用后必须调用关闭方法</p>
<h6 id="2-17-Boxed-value-is-unboxed-and-then-immediately-reboxed">2.17 Boxed value is unboxed and then immediately reboxed</h6>
<p>JAVA 中三目运算时，如果同时存在基本类型和包装类型，JAVA 会自动向下转型拆箱，然后最后进行赋值操作时重新装箱<br>
<br><br>
<font color="#006666">正例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.isTempDrug == <span class="literal">null</span> ? Integer.valueOf(<span class="number">0</span>) : <span class="built_in">this</span>.isTempDrug;</span><br></pre></td></tr></tbody></table></figure>
<h6 id="2-18-Inefficient-use-of-keySet-iterator-instead-of-entrySet-iterator">2.18 Inefficient use of keySet iterator instead of entrySet iterator</h6>
<p>遍历 map 时，如果需要使用到 value 值时，推荐使用 entrySet 而不是 keySet<br>
<br><br>
<font color="#FF0000">反例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; param = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String key : param.keySet()) {</span><br><span class="line">	<span class="comment">// 从map中根据key获取value会浪费性能</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(key, param.get(key)));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="低危（建议修改）">低危（建议修改）</h5>
<h6 id="3-1-Exception-is-caught-when-Exception-is-not-thrown">3.1 Exception is caught when Exception is not thrown</h6>
<p>针对已知异常，根据业务需要分开处理，而不是直接全部归为 Exception<br>
<br><br>
<font color="#006666">正例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>{</span><br><span class="line">　　　　<span class="comment">// do something</span></span><br><span class="line">　　}</span><br><span class="line">　　<span class="keyword">catch</span>(SQLException ex){</span><br><span class="line">　　　　<span class="comment">// do something</span></span><br><span class="line">　　}</span><br><span class="line">　　<span class="keyword">catch</span>(IOException ex){</span><br><span class="line">　　　　<span class="comment">// do something</span></span><br><span class="line">　　}</span><br><span class="line">　　<span class="keyword">catch</span>(Exception ex){</span><br><span class="line">　　　　<span class="comment">// do something</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="3-2-Dead-store-to-local-variable">3.2 Dead store to local variable</h6>
<p>禁止局部变量创建却未使用</p>
<h6 id="3-3-Switch-statement-found-where-default-case-is-missing">3.3 Switch statement found where default case is missing</h6>
<p>switch 出现条件中未添加 break 导致进入 default 的情况<br>
<br><br>
<font color="#FF0000">反例：</font></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (sendOrderRequest.getOrderStatus()) {</span><br><span class="line">    <span class="keyword">case</span> SUCCESS:</span><br><span class="line">        dealSuccess(order, sendOrderRequest);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FAIL:</span><br><span class="line">        dealFail(order, sendOrderRequest);</span><br><span class="line">		<span class="comment">// 此处应该添加break， 防止后续修改时添加default操作导致与预期不符的情况出现</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>spotbugs</tag>
      </tags>
  </entry>
</search>
